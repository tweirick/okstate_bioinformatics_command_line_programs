'''
run_svm_learn.py
@author: Tyler Weirick
@Created on: 6/18/2012 Version 0.0 
@language:Python 3.2
@tags: svm train 

This program handles the 5-fold training and validating process. 
It takes a 

/home/TWeirick/COMBINED_FASTAS_6.7.12/40per_6102012/40per_6102012_fastas/NON_REDUNDANT_FASTAS/40_100_40_FASTAS/FIVE_FOLDER_TRAINING_VECTORS

python3 /home/TWeirick/PY_PROGRAMS/PYSVM/multiclass_five_fold_test_classes.py --help

'''


from multiclass_five_fold_test_functions import *
from sys import exit
from glob import glob
import os
import subprocess
from time import time
from math import *
import tempfile
from random import gauss


class FeaturePoint():
    """
    This class describes a point generated by some type of feature(s).
    It holds a string describing the point as well as the name of the 
    class the point is from and can return the point as a positive 
    negative or named point. 
    """
    def __init__(self,feature_line):
        assert type(feature_line) == str
        split_line = feature_line.split()
        #Make sure that a name exists.
        #@todo: make a regex to recognize proper svm format.
        assert not ":" in split_line[0],"ERROR: Point done not have name"         
        self.example_type       = split_line[0]
        self.true_class_name    = split_line[0]
        self.vector_coordiantes = " ".join(split_line[1:])
        self.predicted_class    = None
        self.value_of_pred      = None
    
    def getPositivepoint(self):
        return "+1 "+self.vector_coordiantes
    def getNegativepoint(self):
        return "-1 "+self.vector_coordiantes
    def getnamedpoint(self):
        return self.example_type+" "+self.vector_coordiantes
    
    ##class SVMClassification():
    
    #def __init__(self,entry_class):
    #    #self.pos_set_class_name = pos_set_class_name
    #    self.true_class_name   = entry_class
    #    self.predicted_class   = None
    #    self.value_of_pred     = None
    
    def updateprediction(self,class_name,value):
        assert type(class_name) == str
        assert type(value)      == float 
        if (self.predicted_class == None and self.value_of_pred == None):
            self.predicted_class   = class_name
            self.value_of_pred     = value 
        else:
           if value > self.value_of_pred:  
               self.predicted_class   = class_name
               self.value_of_pred     = value 
           elif value == self.value_of_pred:
               ewrwe=0
               #print("WARNING: values for",self.predicted_class,self.true_class_name,
               #"and",class_name,"are equal. It could be likely your",
               #"classes have repeats or overlapping sequences.")
           
           
           
    def checkprediction(self,checking_class):
        '''
        if (class_ID == prot_class):
            total_class_seqs+=1
            if (prot_class == class_of_largest_value):
                #True Positive + +)
                #print("True Positive")
                class_calcs_dict[prot_class]["TP"]+=1 
            else:# + and -
                class_calcs_dict[prot_class]["FN"]+=1 
        else:# (class_ID != prot_class):
            if prot_class == class_of_largest_value:# - + 
                class_calcs_dict[prot_class]["FP"]+=1
            else: # - -
                class_calcs_dict[prot_class]["TN"]+=1
        '''
        if checking_class == self.true_class_name:
            if checking_class == self.predicted_class:
                return "TP"
            else:#if self.predicted_class != self.true_class_name:
                return "FN"
        else:#hecking_class != self.true_class_name:
            if checking_class == self.predicted_class:
                return "FP"
            else:#if self.predicted_class != self.true_class_name:
                return "TN"
            

class ClassificationSet():
    """
    This class represents one class within the classification system.
    """
    def __init__(self,class_name,k):
        self.class_name = class_name
        self.FeaturePoint_class_list = []
        self.k = k
        self.remainder      = 0
        self.average_length = 0
        
    def addclasspointlist(self,class_points_list):
        #This should be a complete list of all members of a class.
        #assert type(class_points_list) == list, class_points_list
        self.remainder = len(class_points_list)%self.k
        self.average_length = int(len(class_points_list)/self.k)
        self.FeaturePoint_class_list = class_points_list

    def getsubset(self,i):
        """
        Returns a subset 1/k of the total FeaturePoints in the FeaturePoint 
        class list. 
        """
        start = i*self.average_length
        stop  = start+self.average_length
        if self.remainder > 0:
            stop+=1
            self.remainder-=1
        return self.FeaturePoint_class_list[start:stop]   

    def gettextsubset(self,i):
        """
        Returns a subset 1/k of the total FeaturePoints in the FeaturePoint 
        class list. 
        """
        start = i*self.average_length
        stop  = start+self.average_length
        if self.remainder > 0:
            stop+=1
            self.remainder-=1
        out_list = []
        for e in self.FeaturePoint_class_list[start:stop]:
            out_list.append(e.getnamedpoint())
        return "\n".join(out_list)


class SVMLearnClass():
    
    def __init__(self,class_name,pos_neg_examples_str,test_examples):
        self.pos_examples_are_class = class_name
        self.pos_neg_list  = pos_neg_examples_str
        self.test_examples = test_examples_str
        

class KFoldSet():
    def __init__(self):
        self.general_example_data = []
        self.test_data            = []


class TrainingFile():
    def __init__(self,pcn,tt):
        self.protein_class_name = ""
        self.training_text = ""
        


class Predictions():    
    def __init__(self):
        self.test_file_2D_list = []     



class PlusMinusFile():
    def __init__(self,psn,training_data):
        self.pos_set_name  = psn
        self.training_data = training_data
        #self.test_file     = test_file ,test_fil

#Should be K of these
class KFold():
    
    def __init__(self,pmdl,tf,cd):
        self.plus_minus_data_list = pmdl
        assert type(tf) == str
        self.test_file = tf
        self.calc_data = cd




class PerformanceCalculation():
    
    def __init__(self,FN,FP,TN,TP):
        self.FN = FN
        self.FP = FP
        self.TP = TP
        self.TN = TN
        
    def getaccuracy(self):
        numerator   = 100*(self.TP+self.TN)
        denominator = (self.TP+self.TN+self.FP+self.FN)
        return numerator/denominator
            
    def getprecision(self):
        numerator   = 100*self.TP
        denominator = self.TP+self.FP
        return numerator/denominator
        
    def getsensitivity(self):
        #{"Sensitivity":100*true_pos/(true_pos+false_neg)})
        numerator   = 100*self.TP
        denominator = self.TP+self.FN
        return numerator/denominator
        
    def getspecificity(self):
        #{"Specificity":100*true_neg/(true_neg+false_pos)})
        numerator   = 100*self.TN
        denominator = self.TN+self.FP
        return numerator/denominator
    
    def getMCC(self):
        #numerator = (true_pos*true_neg)-(false_pos*false_neg)
        #denominator = (true_pos+false_pos)*(true_pos+false_neg)*(true_neg+false_pos)*(true_neg+false_neg) 
        numerator   = self.TP*self.TN-self.FP*self.FN
        denominator = sqrt((self.TP+self.FP)*(self.TP+self.FN)*(self.TN+self.FP)*(self.TN+self.FN))
        if denominator == 0:
            return 0
        else:
            return numerator/denominator
    
    def geterror(self):
        #({"Error": 100*numerator/denominator })  numerator   = 100*TP
        #numerator   = (false_pos+false_neg)
        #denominator = (true_pos+true_neg+false_pos+false_neg)
        numerator   = 100*self.FP+self.FN
        denominator = (self.TP+self.TN+self.FP+self.FN)
        return numerator/denominator


        
        